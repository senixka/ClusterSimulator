# Симулятор кластера

Данный репозиторий реализует программный комплекс для тестирования 
алгоритмов планирования задач на кластере. Используется модель 
*заданий (job)* и *задач (task)*. Основой для тестовых данных является
Google cluster data 2011.

## Подготовка репозитория

Для работы данного репозитория требуются большие файлы которые можно скачать по [ссылке](https://drive.google.com/drive/folders/1l0pTKhpoEcrNpO2jsP3HWd_sEILidot4?usp=share_link). 
Чтобы подготовить репозиторий:
- Клонируйте репозиторий.
- Для простого запуска симулятора скачайте и распакуйте в корень репозитория файл `prepared.txt.7z` (при 
распаковке оставьте имя файла `prepared.txt`). Он содержит уже подготовленные входные данные для работы симулятора.
- Если требуется запустить подготовку данных, тогда необходимо скачать файлы логов задач и заданий. Распакуйте их в
папку `data`, которая должна находится в корне репозитория. В результате должны быть две 
директории с файлами логов: `./data/job_events` и `./data/task_events`.

## Тестовые данные

За основу берется *Google cluster data 2011* - это лог событий, 
происходивших на кластере Google длиной в месяц. События разбиты на `job_events` и `task_events`.
Более подробно о событиях и данных можно прочитать в 
[официальной документации](https://drive.google.com/file/d/0B5g07T_gRDg9Z0lsSTEtTWtpOW8/view?resourcekey=0-cozD56gA4fUDdrkHnLJSrQ).

Данные готовятся следующим образом. 
Для каждого задания запоминается время его первого события - это время будет 
далее использовано для моделирования реальной нагрузки появления заданий на кластере. 
Для каждой задачи вычисляется время последнего события ее запуска на кластере. Если 
после последнего события отправки в работу есть событие о завершении задачи, то разница 
считается временем выполнения задачи. Если задача была отправлена, но так и 
не завершилась, то ее время выполнения будет равно UINT64_MAX (данный случай 
характерен для продовых задач). Порядок отправки задач заданием - произвольный (как 
оказалось, более чем у 99.99% заданий первая задача завершается после отправки всех задач). Кроме 
времени выполнения задач также сохраняются их требования к ресурсам в момент запуска.

Код подготовки данных находится в файле `data_prepare.cpp`. Для его запуска:
- Из корня должно быть видно две директории с файлами лога: `./data/job_events` и `./data/task_events`.
- Скомпилируйте и запустите файл `data_prepare.cpp`. Для запуска понадобится не менее 
*15GB* свободной оперативной памяти. Скомпилировать и запустить: `g++ -O3 data_prepare.cpp && ./a.out`.
- Как итог появится файл `prepared.txt`, с подготовленными данными.


## Симулятор

Симулятор реализован в файле `simulator.cpp`. Для его запуска требуется 
файл `prepared.txt` из секции выше или скачанный заранее. Скомпилировать и запустить: `g++ -O3 data_prepare.cpp && ./a.out`.

### Структура кода в `simulator.cpp`:
- `class Task` - выражает одну задачу. Хранит требования к ресурсам, сколько задача 
должна выполнятся, индекс машины выполнения (заполняется при назначении задачи на машину) и время 
завершения задачи (вычисляется при назначении задачи на машину).
- `class JobMaster` - выражает одно задание. Хранит список задач.
- `class Machine` - выражает одну машину. Хранит доступные ресурсы.
  - `class Cluster` - кластер на котором и проходит симуляция. Метод `Update()` используется для 
  выполнения следующего события (задача выполнилась или пришло новое задание). Метод `Schedule()` отвечает 
  за распределение задач по заданиям. Сейчас `Schedule()` перебирает все задачи, которые ожидают выполнения, и 
  размещает каждую на первую же подошедшую машину. Параметр `machineN` - количество машин на кластере. Константа 
  `scheduleEach` - раз во сколько вызовов `Update()` вызывать `Schedule()`. Константа `SPEEDUP_TIME` - на сколько разделить 
  время выполнения задач и время прихода заданий на кластер.

Если сейчас запустить `simulator.cpp`, он будет выводить раз в `scheduleEach` вызовов `Update()` статистику 
кластера: процент свободных ресурсов (процессор, память, диск), а также размеры очередей (количество выполняющихся 
задач, количество выполняющихся заданий, количество еще не прешедших заданий).
