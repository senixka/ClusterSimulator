# Подготовка входных данных
В данной части репозитория находится код подготовки входных данных для симуляций.

Структура:
- `./prepare_job_and_task_from_log.cpp` - использует сырые данные Google для построения входного файла с заданиями и задачами.
Результатом работы является файл `job_and_task.txt` и файлы виды `job_and_task_slice_*.txt`.
- `./prepare_machine_from_log.cpp` - использует сырые данные Google для построения данных о конфигурации кластера.
Результатом работы является файл `machine_orig.txt`.
- `./build/Makefile` - компиляция описанных выше файлов.

## Сборка и запуск
Перейдите в директорию `./build`. Выполните:
- `make prepare_machine_from_log && ./prepare_machine_from_log.out` - для сборки и запуска подготовки данных о машинах.
- `make prepare_job_and_task_from_log && ./prepare_job_and_task_from_log.out` - для сборки и запуска подготовки данных задач и заданий.


## Форматы данных
### Описание конфигурации кластера
Формат файла с описанием конфигурации кластера (например фала `machine_orig.txt`) должен иметь вид:
```
kAllMachine kRow
kMachine_1 kCpu_1 kMemory_1
kMachine_2 kCpu_2 kMemory_2
...
kMachine_<kRow> kCpu_<kRow> kMemory_<kRow>
```

Где:
- Строка вида `kMachine_i kCpu_i kMemory_i` описывает `kMachine_i` штук машин, 
где у каждой машины есть `kCpu_i` единиц процессора и `kMemory_i` единиц памяти.
- `kRow` - общее число строк с описанием машин.
- `kAllMachine` - всего машин на кластере, 
должно быть равно сумме `kMachine_i`.

Все числа целые.

### Описание задач и заданий
Формат файла с описанием задач и заданий (например фал `job_and_task.txt` или файлы вида `job_and_task_slice_*.txt`) должен иметь вид:
```
kAllJob kAllTask

jobTime_1 kEntry_1
count_1_1 estimate_1_1 cpu_1_1 memory_1_1
count_1_2 estimate_1_2 cpu_1_2 memory_1_2
...
count_1_<kEntry_1> estimate_1_<kEntry_1> cpu_1_<kEntry_1> memory_1_<kEntry_1>

jobTime_2 kEntry_2
count_2_1 estimate_2_1 cpu_2_1 memory_2_1
count_2_2 estimate_2_2 cpu_2_2 memory_2_2
...
count_2_<kEntry_2> estimate_2_<kEntry_2> cpu_2_<kEntry_2> memory_2_<kEntry_2>

...

jobTime_<kAllJob> kEntry_<kAllJob>
count_<kAllJob>_1 estimate_<kAllJob>_1 cpu_<kAllJob>_1 memory_<kAllJob>_1
count_<kAllJob>_2 estimate_<kAllJob>_2 cpu_<kAllJob>_2 memory_<kAllJob>_2
...
count_<kAllJob>_<kEntry_2> estimate_<kAllJob>_<kEntry_2> cpu_<kAllJob>_<kEntry_2> memory_<kAllJob>_<kEntry_2>

```

Где:
- Строка вида: `count_i_j estimate_i_j cpu_i_j memory_i_j` описывает `count_i_j` штук задач у `i-ого` задания, 
где каждой задачи требуется `estimate_i_j` времени для выполнения (в секундах), `cpu_i_j` единиц процессора и `memory_i_j` единиц памяти.
- `kEntry_i` описывает количество таких строк (количество различных видов задач).
- `jobTime_i` описывает время прихода задания на кластер.
- `kAllTask` описывает количество задач в симуляции и должно быть равно сумме `count_i_j` по всем `i` и `j`.
- `kAllJob` описывает количество заданий в симуляции.

Все числа целые.

### Общие ограничения и тонкости
Значение ресурса памяти или процессора (как у машин, так и у задач) должно быть целым числом больше нуля и не 
превосходить констант определенных в фале `/simulator/Defines.h` (в данный момент это 1000). 
Значение времени также должно быть целым числом. 
Есть специальное время, равное максимально возможному значению типа времени (на данный момент это `UINT32_MAX`).
Это время используется в значениях `estimate_i_j` и говорит о том, что задача работает до конца симуляции.
Значение `estimate_i_j` не должно быть равно нулю.
Значения времени `jobTime_i` могут быть равны нулю (начальная нагрузка), и не должны быть равны
максимально возможному значению типа времени (на данный момент это `UINT32_MAX`).

## Особенности подготовки и форматов данных
Для выражения количества процессора и количества памяти в логе Google используются дробные числа в диапазоне от 0 до 1. 
Чтобы избежать любых потерь точности во время симуляции было решено использовать 
только целочисленные типы, поэтому при обработке лога количество процессора и памяти
домножаются на 1000, после чего округляются к целому. Если в результате получается число 
равное нулю, то оно заменяется на единицу (это сделано для сохранения информации о
задачах с очень маленьким запросом к ресурсам). Константа 1000 была выбрана после 
проведения анализа используемого лога.

Также отдельно стоит сказать о работе со временем. 
В логе время выражается в микросекундах (это связано с тем, что в логе регистрируется 
огромное количество различных событий, часть из которых оказалась бесполезной для
построения входных данных для симуляции). Поэтому в симуляторе время выражается в
секундах и при обработке лога, оно округляется до секунд.

Еще стоит сказать про наличие начальной нагрузки. В логе есть информация о том какие задания и задачи уже работали 
на кластере в момент старта записи данного лога, для таких заданий используется время прихода на кластер ноль.

Так для работы симулятора требуется описать два файла. Первый файл содержит информацию 
о машинах: вид машины (количество процессора и памяти) и сколько требуется
создать машин каждого вида. Всю эту информацию о машинах можно получить напрямую
из лога, поэтому при симуляциях стало возможно воспроизвести не только оригинальную
нагрузку заданий и задач, но и оригинальную конфигурацию кластера (количество машин
и их ресурсы). Второй файл содержит информацию о времени прихода каждого задания
на кластер и информацию о задачах каждого задания. Для каждой задачи дается описание
(три числа) – требуемое количество процессора, требуемое количество памяти и то, сколько
эта задача будет выполняться на машине. Эта информация уже не содержится в логе напрямую. 
Для каждой задачи в логе есть последовательность событий, которая в общем
случае может выглядеть весьма не тривиально. Так например некоторая задача могла быть
передана планировщику для планирования, потом через некоторое время для нее нашлись
ресурсы и ее отправили на машину, после она могла быть отменена и перепланирована на
другую машину (могли измениться запросы задачи к ресурсам или она могла быть вытеснена
более приоритетной задачей), и так несколько раз подряд. Каждое такое событие содержит
время регистрации и текущие требования к ресурсам этой задачи. В качестве времени выполнения
при формировании входных данных для симуляции использовалась разница между
последним назначением задачи на машину и ее непосредственным завершением (требования
к ресурсам берутся из события назначения на машину). Отдельно стоит сказать, что есть
задачи, у которых нет события завершения в логе (например так могут вести себя сервисы в продакшене). 
Для таких задач время выполнения ставится максимально возможным,
поэтому после назначения на машины, они будут работать до конца симуляции.

Для проведения симуляций было решено использовать два типа входных данных. Первый тип входных данных – обработанный полный лог, 
обработка и подготовка которого была описана выше. Второй тип входных данных – срезы. Исходные
входные данные (длиной в месяц), нарезаются на 10 входных файлов следующим образом.
Длина среза по времени всегда равна одной недели. Первый срез является в точности первой
неделей исходных данных, далее это окно в неделю сдвигается на некоторый сдвиг `Shift` так,
что начало следующего среза – есть начало предыдущего среза + `Shift`. `Shift` выбирается
таким образом, чтобы конец последнего среза был в точности равен концу исходных данных.
В случае использующихся входных данных построенных из лога, `Shift` составил чуть больше
двух дней. Дополнительно к каждому срезу кроме первого, в начало, добавляется начальная
нагрузка (о которой говорилось выше). Она добавляется для того, чтобы сразу получить 
загруженный кластер.

